package opencc

import (
	"encoding/json"
	"html/template"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

type (
	Segmentation struct {
		Type string   `json:"type"`
		Dict DictFile `json:"dict"`
	}

	DictFile struct {
		Type string `json:"type"`
		File string `json:"file"`
	}

	Dict struct {
		Type  string     `json:"type"`
		File  string     `json:"file"`
		Dicts []DictFile `json:"dicts"`
	}

	ConversionChain struct {
		Dict Dict `json:"dict"`
	}

	Config struct {
		Name             string            `json:"name"`
		Segmentation     Segmentation      `json:"segmentation"`
		ConversionChains []ConversionChain `json:"conversion_chain"`
	}
)

func TestGenerateDicts(t *testing.T) {
	generateDicts()
}

func generateDicts() {
	files, err := filepath.Glob("OpenCC-src/data/config/*.json")
	if err != nil {
		panic(err)
	}
	if len(files) == 0 {
		return
	}

	configs := map[string]Config{}
	nameMaxLen := 0
	for _, file := range files {
		f, err := os.Open(file)
		if err != nil {
			panic(err)
		}
		defer f.Close()
		decoder := json.NewDecoder(f)
		var config Config
		if err = decoder.Decode(&config); err != nil {
			panic(err)
		}
		base := filepath.Base(file)
		name := strings.TrimSuffix(base, filepath.Ext(base))
		configs[name] = config
		if len(name) > nameMaxLen {
			nameMaxLen = len(name)
		}
	}

	tpl := template.Must(template.New("configs").Funcs(template.FuncMap{
		"base": func(name string) string {
			return strings.TrimSuffix(name, filepath.Ext(name))
		},
		"padSpaces": func(name string) string {
			return strings.Repeat(" ", nameMaxLen-len(name))
		},
	}).Parse(`// this file is generated by dicts_test.go

package opencc

import (
	"github.com/caiguanhao/opencc/dicts"
	"github.com/liuzl/da"
)

var (
	Dictionaries = map[string]string{
	{{- range $name, $config := .}}
		"{{$name}}": {{$name | padSpaces}}"{{$config.Name}}",
	{{- end}}
	}
)

func dictsForName(name string) [][]*da.Dict {
	{{- range $name, $config := .}}
	if name == "{{$name}}" {
		return [][]*da.Dict{
		{{- range $config.ConversionChains}}
			{{- if .Dict.File}}
			{
				dicts.{{.Dict.File | base}},
			},
			{{- end}}
			{{- if .Dict.Dicts}}
			{
				{{- range .Dict.Dicts}}
				dicts.{{.File | base}},
				{{- end}}
			},
			{{- end}}
		{{- end}}
		}
	}
	{{- end}}
	return nil
}
`))
	f, err := os.Create("dicts.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	err = tpl.Execute(f, configs)
	if err != nil {
		panic(err)
	}
}
