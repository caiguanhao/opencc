package opencc

import (
	"encoding/json"
	"html/template"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"testing"
)

type (
	Segmentation struct {
		Type string   `json:"type"`
		Dict DictFile `json:"dict"`
	}

	DictFile struct {
		Type string `json:"type"`
		File string `json:"file"`
	}

	Dict struct {
		Type  string     `json:"type"`
		File  string     `json:"file"`
		Dicts []DictFile `json:"dicts"`
	}

	ConversionChain struct {
		Dict Dict `json:"dict"`
	}

	Config struct {
		Name             string            `json:"name"`
		Segmentation     Segmentation      `json:"segmentation"`
		ConversionChains []ConversionChain `json:"conversion_chain"`
	}
)

func TestGenerateDicts(t *testing.T) {
	generateDicts()
}

func generateDicts() {
	files, err := filepath.Glob("OpenCC-src/data/config/*.json")
	if err != nil {
		panic(err)
	}
	if len(files) == 0 {
		return
	}

	configs := map[string]Config{}
	nameMaxLen := 0
	dictsMap := map[string]bool{}
	for _, file := range files {
		f, err := os.Open(file)
		if err != nil {
			panic(err)
		}
		defer f.Close()
		decoder := json.NewDecoder(f)
		var config Config
		if err = decoder.Decode(&config); err != nil {
			panic(err)
		}
		for _, d := range config.ConversionChains {
			if d.Dict.File != "" {
				dictsMap[d.Dict.File] = true
			}
			for _, d := range d.Dict.Dicts {
				dictsMap[d.File] = true
			}
		}
		base := filepath.Base(file)
		name := strings.TrimSuffix(base, filepath.Ext(base))
		configs[name] = config
		if len(name) > nameMaxLen {
			nameMaxLen = len(name)
		}
	}
	dicts := []string{}
	for dict := range dictsMap {
		dicts = append(dicts, dict)
	}
	sort.Strings(dicts)

	tpl := template.Must(template.New("configs").Funcs(template.FuncMap{
		"base": func(name string) string {
			return strings.TrimSuffix(name, filepath.Ext(name))
		},
		"padSpaces": func(name string) string {
			return strings.Repeat(" ", nameMaxLen-len(name))
		},
	}).Parse(`// this file is generated by dicts_test.go

package opencc

import (
	{{- range .Dicts}}
	"github.com/caiguanhao/opencc/dicts/{{. | base}}"
	{{- end}}
	"github.com/liuzl/da"
)

var (
	Dictionaries = map[string]string{
	{{- range $name, $config := .Configs}}
		"{{$name}}": {{$name | padSpaces}}"{{$config.Name}}",
	{{- end}}
	}
)

func dictsForName(name string) [][]*da.Dict {
	{{- range $name, $config := .Configs}}
	if name == "{{$name}}" {
		return [][]*da.Dict{
		{{- range $config.ConversionChains}}
			{{- if .Dict.File}}
			{
				{{.Dict.File | base}}.Dict,
			},
			{{- end}}
			{{- if .Dict.Dicts}}
			{
				{{- range .Dict.Dicts}}
				{{.File | base}}.Dict,
				{{- end}}
			},
			{{- end}}
		{{- end}}
		}
	}
	{{- end}}
	return nil
}
`))
	f, err := os.Create("dicts.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	err = tpl.Execute(f, struct {
		Configs map[string]Config
		Dicts   []string
	}{configs, dicts})
	if err != nil {
		panic(err)
	}
}
