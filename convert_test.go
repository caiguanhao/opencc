package opencc

import (
	"encoding/json"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"testing"
)

type (
	Segmentation struct {
		Type string   `json:"type"`
		Dict DictFile `json:"dict"`
	}

	DictFile struct {
		Type string `json:"type"`
		File string `json:"file"`
	}

	Dict struct {
		Type  string     `json:"type"`
		File  string     `json:"file"`
		Dicts []DictFile `json:"dicts"`
	}

	ConversionChain struct {
		Dict Dict `json:"dict"`
	}

	Config struct {
		Name             string            `json:"name"`
		Segmentation     Segmentation      `json:"segmentation"`
		ConversionChains []ConversionChain `json:"conversion_chain"`
	}
)

func TestGenerateDicts(t *testing.T) {
	generateDicts()
}

func TestAllCases(t *testing.T) {
	files, err := filepath.Glob("OpenCC-src/test/testcases/*.in")
	if err != nil {
		panic(err)
	}
	for _, file := range files {
		content, err := ioutil.ReadFile(file)
		if err != nil {
			panic(err)
		}
		base := filepath.Base(file)
		name := strings.TrimSuffix(base, filepath.Ext(base))
		fmt.Println("testing", name)
		expected, err := ioutil.ReadFile("OpenCC-src/test/testcases/" + name + ".ans")
		if err != nil {
			panic(err)
		}
		actual := Convert(name, string(content))
		if actual != string(expected) {
			t.Fatal("bad case for", name, "expect", actual, "to be", string(expected))
		}
	}
}

func generateDicts() {
	files, err := filepath.Glob("OpenCC-src/data/config/*.json")
	if err != nil {
		panic(err)
	}
	if len(files) == 0 {
		return
	}

	names := []string{}
	nameMaxLen := 0

	for _, file := range files {
		f, err := os.Open(file)
		if err != nil {
			panic(err)
		}
		defer f.Close()
		decoder := json.NewDecoder(f)
		var config Config
		if err = decoder.Decode(&config); err != nil {
			panic(err)
		}

		dictsMap := map[string]bool{}
		for _, d := range config.ConversionChains {
			if d.Dict.File != "" {
				dictsMap[d.Dict.File] = true
			}
			for _, d := range d.Dict.Dicts {
				dictsMap[d.File] = true
			}
		}
		dicts := []string{}
		for dict := range dictsMap {
			dicts = append(dicts, dict)
		}
		sort.Strings(dicts)

		base := filepath.Base(file)
		name := strings.TrimSuffix(base, filepath.Ext(base))

		if len(name) > nameMaxLen {
			nameMaxLen = len(name)
		}
		names = append(names, name)

		tpl := template.Must(template.New("configs").Funcs(template.FuncMap{
			"base": func(name string) string {
				return strings.TrimSuffix(name, filepath.Ext(name))
			},
		}).Parse(`// this file is generated by convert_test.go

package {{.Name}}

import (
	"github.com/caiguanhao/opencc/configs"
	{{- range .Dicts}}
	"github.com/caiguanhao/opencc/dicts/{{. | base}}"
	{{- end}}
)

const (
	Description = "{{.Config.Name}}"
)

var (
	Dicts = configs.Dicts{
		{{- range .Config.ConversionChains}}
		{{- if .Dict.File}}
		{
			{{.Dict.File | base}}.Dict,
		},
		{{- end}}
		{{- if .Dict.Dicts}}
		{
			{{- range .Dict.Dicts}}
			{{.File | base}}.Dict,
			{{- end}}
		},
		{{- end}}
		{{- end}}
	}
)
`))
		if err := os.MkdirAll("configs/"+name, 0755); err != nil {
			panic(err)
		}
		fi, err := os.Create("configs/" + name + "/main.go")
		if err != nil {
			panic(err)
		}
		defer fi.Close()
		err = tpl.Execute(fi, struct {
			Name   string
			Config Config
			Dicts  []string
		}{name, config, dicts})
		if err != nil {
			panic(err)
		}
	}

	tpl := template.Must(template.New("configs").Funcs(template.FuncMap{
		"padSpaces": func(name string) string {
			return strings.Repeat(" ", nameMaxLen-len(name))
		},
	}).Parse(`// this file is generated by convert_test.go

package opencc

import (
	"github.com/caiguanhao/opencc/configs"
	{{- range .Names}}
	"github.com/caiguanhao/opencc/configs/{{.}}"
	{{- end}}
)

var (
	Dictionaries = map[string]string{
	{{- range .Names}}
		"{{.}}": {{. | padSpaces}}{{.}}.Description,
	{{- end}}
	}
)

func Convert(dictionary, in string) string {
	dicts := dictsForName(dictionary)
	return dicts.Convert(in)
}

func dictsForName(name string) configs.Dicts {
	{{- range .Names}}
	if name == "{{.}}" {
		return {{.}}.Dicts
	}
	{{- end}}
	return nil
}
`))
	fi, err := os.Create("convert.go")
	if err != nil {
		panic(err)
	}
	defer fi.Close()
	err = tpl.Execute(fi, struct {
		Names []string
	}{names})
	if err != nil {
		panic(err)
	}
}
