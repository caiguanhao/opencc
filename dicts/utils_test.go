package dicts

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/liuzl/da"
)

func TestGenerateDicts(t *testing.T) {
	generateDicts()
}

func generateDicts() {
	content, err := ioutil.ReadFile("../dicts.go")
	if err != nil {
		panic(err)
	}
	matches := regexp.MustCompile("dicts\\.(\\w+)").FindAllStringSubmatch(string(content), -1)
	names := []string{}
	for _, match := range matches {
		exists := false
		for _, n := range names {
			if n == match[1] {
				exists = true
			}
		}
		if !exists {
			names = append(names, match[1])
		}
	}
	for i, name := range names {
		p := "../OpenCC-src/data/dictionary/" + name + ".txt"
		if !fileExists(p) {
			p = "../OpenCC-src/build/Release/" + name + ".txt"
		}
		if !fileExists(p) {
			panic(name + ".txt not found")
		}
		names[i] = p
	}
	if len(names) == 0 {
		return
	}
	for _, file := range names {
		generateDict(file)
	}
}

func generateDict(file string) {
	fmt.Println("processing", file)
	dict, err := da.BuildFromFile(file)
	if err != nil {
		panic(err)
	}

	var b bytes.Buffer
	if err := dict.Trie.Save(&b, "gob"); err != nil {
		panic(err)
	}

	tpl := template.Must(template.New("dicts").Delims("<<", ">>").
		Funcs(template.FuncMap{
			"mod": func(i, j int) bool {
				return i%j == 0
			},
			"hex": func(i uint8) string {
				return fmt.Sprintf("0x%02X", i)
			},
		}).Parse(`// this file is generated by utils_test.go

package dicts

import (
	"github.com/liuzl/da"
)

var <<.Name>> = &da.Dict{
	Trie: loadCedarFromGOB([]byte{
		<<- range $i, $t := .TrieBytes>><<if mod $i 10>>
		<<else>> <<end>><<$t | hex>>,<<- end>>
	}),
	Values: [][]string{
	<<- range .Values>>
		{<<range $i, $t := .>><<if gt $i 0>>, <<end>>"<<$t>>"<<end>>},
	<<- end>>
	},
}
`))

	base := filepath.Base(file)
	name := strings.TrimSuffix(base, filepath.Ext(base))

	f, err := os.Create("dict_" + name + ".go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = tpl.Execute(f, struct {
		*da.Dict
		Name      string
		TrieBytes []byte
	}{dict, name, b.Bytes()})
	if err != nil {
		panic(err)
	}
}

func fileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}
